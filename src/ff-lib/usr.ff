'core.ff' import use
'shuffle.ff' import use
'math.ff' import use
'strings.ff' import use
'types.ff' import use
'datetime.ff' import use

$: [ dip eval ] ; 

// Misc
compose: [ + ] ;
prepose: [ swap + ] ;

with: [ [ swap [ swap ] ] dip + >> ] ;
eval2: [ slip eval ] ;
replicate: [ [ unit ] dip * ] ;
nth: [ -- @ ] ;

// side effects
trace: [ trace: set-log-level ] ;
timing: [ timing: set-log-level ] ;

// quick check
for-all: [ [ [ 100 times ] >> in ] dip [ ~ ] + filter ] ;
check-for-all: [ for-all dup empty? [ '+++ OK, passed 100 tests.' println drop ] [ [ ' Failed!' + println ] map ] branch ] ;

// generators
next-fib*: [ tuck + ] ;
fib*: [ ( 0 1 ) dip [ 0 1 [ tuck + ] yield ] [ in ] rolldown 2 - repn drop ] ;
count*: [ [ 0 [ ++ dup yield: dip ] forever ] ] ;
cycle*: [ [ [ 1 splitat swap [ + ] keep eval send suspend ] forever ] >> ] ;

// async
spawnsplit: [ spawn2 eval2 ] ;
spawn2: [ [ spawn ] dip spawn ] ;

// fetch
fetch-json: [ read parse-json ] ;
site-size: [ read length ] ;
site-war: [ dup [ [ site-size ] >> ] map all zip object ] ;

// random
rand-integer: [ rand-u32 ] ;
rand-char: [ rand-integer 128 % itoa ] ;
rand-seq: [ rand-integer 16 % ++ [ times ] >> >> in ] ;
rand-string: [ [ rand-char ] rand-seq sum ] ;
rand-bool: [ rand-u32 even? ] ;

// repl
cls: [ "\u001B[2J\u001B[0;0f" println ] ;
