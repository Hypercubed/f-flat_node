core: using
shuffle: using
math: using

'datetime.ff' import

// Misc
compose: [ + ] ;
prepose: [ swap + ] ;

with: [ [ swap [ swap ] ] dip + >> ] ;
eval2: [ slip eval ] ;
replicate: [ [ unit ] dip * ] ;
nth: [ -- @ ] ;

// side effects
trace: [ trace: set-log-level ] ;
timing: [ timing: set-log-level ] ;

// quick check
for-all: [ [ [ 100 times ] >> in ] dip [ ~ ] + filter ] ;
check-for-all: [ for-all dup empty? [ '+++ OK, passed 100 tests.' println drop ] [ [ ' Failed!' + println ] map ] branch ] ;

// strings
lcase-char: [ dup ucase-char? [ atoi 32 + itoa ] when ] ;
ucase-char: [ dup lcase-char? [ atoi 32 - itoa ] when ] ;
rot13-char*: [ [ atoi ] dip [ - 13 + 26 % ] [ + ] bi itoa ] ;
rot13-char: [ dup ucase-char? [ 65 ] [ 97 ] branch rot13-char* ] ;
char-map: [ map sum ] ;
rot13: [ [ rot13-char ] char-map ] ;
ucase: [ [ ucase-char ] char-map ] ;
lcase: [ [ lcase-char ] char-map ] ;

// generators
next-fib*: [ tuck + ] ;
fib*: [ ( 0 1 ) dip [ 0 1 [ tuck + ] yield ] [ in ] rolldown 2 - repn drop ] ;
count*: [ [ 0 [ ++ dup yield: dip ] forever ] ] ;
cycle*: [ [ [ 1 splitat swap [ + ] keep eval send suspend ] forever ] >> ] ;

// async
spawnsplit: [ spawn2 eval2 ] ;
spawn2: [ [ spawn ] dip spawn ] ;

// fetch
fetch-json: [ read parse-json ] ;
site-size: [ read length ] ;
site-war: [ dup [ [ site-size ] >> ] map all zip object ] ;

// random
rand-integer: [ rand-u32 ] ;
rand-char: [ rand-integer 128 % itoa ] ;
rand-seq: [ rand-integer 16 % ++ [ times ] >> >> in ] ;
rand-string: [ [ rand-char ] rand-seq sum ] ;
rand-bool: [ rand-u32 even? ] ;

// math-ish
integers: [ [ count ] appl ] ;
divisors: [ [ 2 [ 2dup 2 ^ > ] [ 2dup divisor? [ tuck / over ] [ next-odd ] branch ] while drop ] appl ] ;
next-fib: [ 2dup + ] ;
fib: [ ( 0 1 [ next-fib ] ) dip -- repn drop ] ;
collatz: [ [ [ dup 1 > ] [ dup next-collatz ] while ] >> in ] ;
next-collatz: [ dup even? [ 2 / ] [ 3 * 1 + ] branch ] ;
divrem: [ [ div ] [ % ] bi2 ] ;
gcd: [ [ dup 0 > ] [ dup bury % ] while drop ] ;
lcm: [ 2dup [ [ * abs ] dip ] dip gcd / ] ;

// inquisitive
either?: [ bi@ + ] ;
lcase-char?: [ atoi [ 96 123 ] dip between? ] ;
ucase-char?: [ atoi [ 64 91 ] dip between? ] ;
empty?: [ length zero? ] ;
between?: [ swap dupd < bury < * ] ;
char?: [ [ lcase-char? ] [ ucase-char? ] bi or ] ;

// repl
cls: [ "\u001B[2J\u001B[0;0f" println ] ;

