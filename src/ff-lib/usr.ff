'shuffle.ff' require
'testing.ff' require
'switch-patterns.ff' require

!!: [ null? ~ ] ;

// Misc
compose: [ + ] ;
prepose: [ swap + ] ;

with: [ [ swap [ swap ] ] dip + >> ] ;
eval2: [ slip eval ] ;
replicate: [ [ unit ] dip * ] ;
nth: [ -- @ ] ;

// with-system-property: [ 
//   over get-system-property
//   [ dupd set-system-property ] dip
//   swapd swap
//   in
//   [ set-system-property ] dip
// ] ;

// side effects
timing-on: [ 'log-level' 'timing' set-system-property ] ;
timing-off: [ 'log-level' 'warn' set-system-property ] ;

// quick check
for-all: [ [ [ 100 times ] appl ] dip [ ~ ] + filter ] ;
check-for-all: [ for-all dup empty? [ '+++ OK, passed 100 tests.' println drop ] [ [ ' Failed!' + println ] map ] branch ] ;

// generators
next-fib*: [ tuck + ] ;
fib*: [ ( 0 1 ) dip [ 0 1 [ tuck + ] yield ] [ in ] rolldown 2 - times drop ] ;
count*: [ [ 0 [ ++ dup [ yield ] dip ] forever ] ] ;
// cycle*: [ [ [ 1 splitat swap [ + ] keep eval send suspend ] forever ] >> ] ;

// async
spawn2: [ [ spawn ] dip spawn ] ;
spawnsplit: [ spawn2 eval2 ] ;

// fetch
site-size: [ read ln ] ;
site-war: [ dup [ [ site-size ] >> ] map all interleave object ] ;

// random
rand-integer: [ rand-u32 ] ;
rand-char: [ rand-integer 128 % itoa ] ;
rand-seq: [ rand-integer 16 % ++ ++ ++ ++ [ times ] >> >> in ] ;
rand-string: [ [ rand-char ] rand-seq sum ] ;
rand-bool: [ rand-u32 even? ] ;

// repl
cls: [ "\u001B[2J\u001B[0;0f" println ] ;

// short circuit logicals
&&: [ [ dup truthy? swap ] dip swap choose ] ;

    [ true false && assert-false ] '&&' test
    [ false true && assert-false ] '&&' test
    [ 'true' 'false' && 'false' assert-equal ] '&&' test
    [ '' 'false' && '' assert-equal ] '&&' test
    [ 0 'false' && 0 assert-equal ] '&&' test

||: [ [ dup truthy? swap ] dip choose ] ;

    [ true false || assert ] '||' test
    [ false true || assert ] '||' test
    [ 'true' 'false' || 'true' assert-equal ] '||' test
    [ '' 'false' || 'false' assert-equal ] '||' test
    [ 0 'false' || 'false' assert-equal ] '||' test

// nullish coalescing operator
??: [ [ dup null? ~ swap ] dip choose ] ;

    [ true false ?? assert ] '??' test
    [ null true ?? assert ] '??' test
    [ 'true' 'false' ?? 'true' assert-equal ] '??' test
    [ null 'false' ?? 'false' assert-equal ] '??' test
    [ null 'false' ?? 'false' assert-equal ] '??' test

p-reverse: [
  dup ln
  [
    [ 0 p-case [] ]
    [ 1 p-case [] ]
    [ _ p-case [ popl p-reverse swap + ] ]
  ]
  switch
] ;

/**
 * The quadratic equation using lambdas
 */
quad: [
  [ a: b: c: ] => [
    .b -1 * .b .b * 4 .a .c * * - sqrt -+
    [ 2 .a * / ] bi@
  ] lambda
] ;

    [ 1 -3 0 quad 3 assert-equal 0 assert-equal ] 'quadradic equation lambda' test
    [ 5 6 1 quad -0.2 assert-equal -1 assert-equal ] 'quadradic equation lambda' test
    [ 5 2 1 quad -0.2 0.4 i * + assert-equal -0.2 -0.4 i * + assert-equal ] 'quadradic equation lambda' test

phi: ( 1 5 sqrt + 2 / ) ;  // the golden ratio
psi: ( phi inv ~ ) ;

lucas: [ phi swap ^ floor ] ;
binet: [ [ phi swap ^ ] [ psi swap ^ ] bi - 5 sqrt / ] ;

fib: [
  [
    [ 0        p-case [ ]]
    [ 1        p-case [ ]]
    [ [ 10 > ] case   [ binet round ]]
    [ [ 0 <  ] case   [ abs dup 1 + -1 swap ^ swap fib * ]]
    [ true            [ [1 - fib]  [2 - fib] bi + ]]
  ] switch
] ;

ls: [
  words [ show ] map 
] ;

// guards?
_stackn: [ [ ] swap [ >> ] swap times dup slip ] ;
==>: [ dup ln [ _stackn ] >> dip [ eval ] zipwith true swap [ * ] each ] ;  // guard

    [ 1 "2" 0 [ number? string? zero? ] ==> assert ] '==>' test
    [ 1 0 [ number? zero? ] ==> [ 'undef' ] [ / ] branch 'undef' assert-equal ] '==>' test
    [ 1 2 [ number? zero? ] ==> [ 'undef' ] [ / ] branch 0.5 assert-equal ] '==>' test

