'math.ff' require
'shuffle.ff' require
'strings.ff' require
'datetime.ff' require
'testing.ff' require
'lambdas.ff' require

!!: [ null? ~ ] ;;
?@: [ [ dup !! ] dip [ @ ] >> [ drop null ] branch ] ;

// Misc
compose: [ + ] ;
prepose: [ swap + ] ;

with: [ [ swap [ swap ] ] dip + >> ] ;
eval2: [ slip eval ] ;
replicate: [ [ unit ] dip * ] ;
nth: [ -- @ ] ;
dupn: [ [ dup ] swap times ] ;

with-system-property: [ 
  over get-system-property
  [ dupd set-system-property ] dip
  swapd swap
  in
  [ set-system-property ] dip
] ;

// side effects
traceoff: [ 'log-level' 'warn'  set-system-property ] ;
traceon: [ 'log-level' 'trace' set-system-property ] ;
timing: [ 'log-level' 'timing' set-system-property ] ;
trace: [ traceon eval traceoff ] ; // doesn't work!!

// quick check
for-all: [ [ [ 100 times ] >> in ] dip [ ~ ] + filter ] ;
check-for-all: [ for-all dup empty? [ '+++ OK, passed 100 tests.' println drop ] [ [ ' Failed!' + println ] map ] branch ] ;

// generators
next-fib*: [ tuck + ] ;
fib*: [ ( 0 1 ) dip [ 0 1 [ tuck + ] yield ] [ in ] rolldown 2 - times drop ] ;
count*: [ [ 0 [ ++ dup [ yield ] dip ] forever ] ] ;
// cycle*: [ [ [ 1 splitat swap [ + ] keep eval send suspend ] forever ] >> ] ;

// async
spawn2: [ [ spawn ] dip spawn ] ;
spawnsplit: [ spawn2 eval2 ] ;

// fetch
fetch-json: [ read parse-json ] ;
site-size: [ read ln ] ;
site-war: [ dup [ [ site-size ] >> ] map all zip object ] ;

// random
rand-integer: [ rand-u32 ] ;
rand-char: [ rand-integer 128 % itoa ] ;
rand-seq: [ rand-integer 16 % ++ ++ ++ ++ [ times ] >> >> in ] ;
rand-string: [ [ rand-char ] rand-seq sum ] ;
rand-bool: [ rand-u32 even? ] ;

// repl
cls: [ "\u001B[2J\u001B[0;0f" println ] ;

// switch
stack-copy: [ stack run ] ;
stack-check: [ q< stack-copy q> =~ ] ;;
case: [ [ stack-check ] dip when ] ;;
switch: [ [ unstack case ] each ] ;;

// short circuit logicals
&&: [ slip when ] ;;
||: [ slip [] swap branch ] ;;

quicksort: [
  dup ln 1 >             // when length > 1
  [
    uncons                         // split into first [ ...rest ]
    over dup                    // shuffle
    [ [ <= ] >> filter ] >>     // filter values less than or equal to pivot
    swap [ [ > ] >> filter ] >> // filter values greater than the pivot
    bi
    [ quicksort ] bi@           // quicksort each sublist
    [ swap + ] dip +            // merge results 
  ] when
] ;

    [
      [ 3 2 1 ] quicksort [ 1 2 3 ] assert_equal
      [ -3 2 1 ] quicksort [ -3 1 2 ] assert_equal
      [ -3 2 -1 ] quicksort [ -3 -1 2 ] assert_equal
    ] 'quicksort' test

p-reverse: [
  dup ln
  [
    [ 0 [] ]
    [ 1 [] ]
    [ _ [ uncons p-reverse swap + ] ]
  ]
  p-cond
] ;

/**
 * The quadratic equation using lambdas
 */
quad: [
  [ a: b: c: ] => [
    .b -1 * .b .b * 4 .a .c * * - sqrt -+
    [ 2 .a * / ] bi@
  ]
] lambda ;

    [ 1 -3 0 quad 3 assert_equal 0 assert_equal ] 'quadradic equation lambda' test
    [ 5 6 1 quad -0.2 assert_equal -1 assert_equal ] 'quadradic equation lambda' test
    [ 5 2 1 quad -0.2 0.4 i * + assert_equal -0.2 -0.4 i * + assert_equal ] 'quadradic equation lambda' test

s-test: [
  `
  Multi line string
  Hello
  World
  `
] ;

