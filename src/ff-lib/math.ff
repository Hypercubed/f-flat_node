/**
 * # Mathematics lib
 */
 
'core.ff' import use
'shuffle.ff' import use

// inverse trig
acos: [ asin 2 * pi swap - 1 2 / * ] ;
// atan: [ dup dup * 1 + sqrt / asin ] ;

// lazy constants to match precision
pi: [ 1 atan 4 * ] ;
e: [ 1 exp ] ;              // Euler's number
ln2: [ 2 ln ] ;             // natural logarithm of 2
ln10: [ 10 ln ] ;           // natural logarithm of 10
log2e: [ 1 ln2 / ] ;        // base 2 logarithm of E
log10e: [ 1 ln10 / ] ;      // base 10 logarithm of E
tau: [ pi 2 * ] ;
phi: [ 1 5 sqrt + 2 / ] ;   // golden ratio
sqrt2: [ 2 sqrt ] ;         // square root of 2
sqrt1_2: [ 1 2 / sqrt ] ;   // square root of 1/2
radians: [ pi 180 / ] ;

// Log errfn
erfc: [ 1 swap erf - ] ;
log: [ ln ln10 / ] ;
logn: [ [ ln ] dip ln / ] ;

// Misc
+-: [ [ + ] [ - ] bi2 ] ;
-+: [ [ - ] [ + ] bi2 ] ;
inv: [ 1 swap / ] ;
sq: [ dup * ] ;
sum-of-squares: [ 0 [ sq + ] reduce ] ;
square-of-sum: [ sum sq ] ;

// angles
toradians: [ radians * ] ;
todegrees: [ radians / ] ;

// hyperbolic trig
cosh: [ exp dup inv + 2 / ] ;
sinh: [ exp dup inv - 2 / ] ;
tanh: [ 2 * exp pred swap ++ / ] ;

// inverse hyperbolic trig
complex: [ 0 i * + ] ;
asinh: [ complex dup dup * ++ sqrt + ln ] ;
acosh: [ complex dup -- sqrt over 1 + sqrt * + ln ] ;
atanh: [ i * atan i / ] ;

// inquisitive
integer?: [ dup [ floor = ] [ im 0 = ] bi * ] ;
positive?: [ 0 > ] ;
negitive?: [ 0 < ] ;
zero?: [ 0 = ] ;
divisor?: [ % zero? ] ;
even?: [ 2 divisor? ] ;
odd?: [ even? ~ ] ;
simple?: [ [ even? ] [ 3 divisor? ] [ 5 divisor? ] tri + + ] ;

// sequences
find-next: [ [ ++ dup ] swap + [ ~ ] + loop ] ;
next-odd: [ [ odd? ] find-next ] ;
next-even: [ [ even? ] find-next ] ;
countup: [ over - [ succ ] swap ] ;
countdown: [ dupd - [ pred ] swap ] ;
range*: [ 2dup < [ countup ] [ countdown ] branch repn ] ;
range: [ [ range* ] >> appl ] ;
count: [ 1 swap range* ] ;

// primes
prime?*: [ 2 [ 2dup 2 ^ > [ 2dup % 0 > ] dip swap * ] [ ++ ] while 2 ^ < ] ;
prime?: [ dup 7 < [ [ 2 = ] [ 3 = ] [ 5 = ] tri + + ] [ dup simple? [ drop false ] [ prime?* ] branch ] branch ] ;
mersenne?: [ 2 swap ^ 1 - prime? ] ;
next-prime: [ dup 2 < [ drop 2 ] [ next-odd [ dup prime? ] [ 2 + ] until ] branch ] ;
nth-prime: [ [ 0 [ next-prime ] ] dip times ] ;

// Kunth
^^^: [ -- dup [ [ dup ] swap times [ ^^ ] ] dip times ] ;
^^: [ -- dup [ [ dup ] swap times [ ^ ] ] dip times ] ;
pow: [ -- dup [ [ dup ] swap times [ * ] ] dip times ] ;
mul: [ -- dup [ [ dup ] swap times [ + ] ] dip times ] ;

// Factorials
approx-fact: [ ++ gamma ] ;
// c!: [ pred [ count ] dip [ * ] swap times ] ;
recur-fact: [ dup zero? [ drop 1 ] [ pred recur-fact eval * ] branch ] ;
// y!: [ [ [ over zero? ] [ drop ++ ] [ [ pred ] dip eval * ] ifte ] y eval ] ;
!: [ dup integer? [recur-fact] [approx-fact] choose eval ] ;

// Prob
npr: [ [ [ ! ] keep ] dip - ! / ] ;
ncr: [ [ npr ] keep ! / round ] ;

// reduce
product: [ [ * ] reduce* ] ;
dot: [ [ * ] zipwith sum ] ;

// math-ish
integers: [ [ count ] appl ] ;
divisors: [ [ 2 [ 2dup 2 ^ > ] [ 2dup divisor? [ tuck / over ] [ next-odd ] branch ] while drop ] appl ] ;
next-fib: [ 2dup + ] ;
fib: [ ( 0 1 [ next-fib ] ) dip -- repn drop ] ;
collatz: [ [ [ dup 1 > ] [ dup next-collatz ] while ] >> in ] ;
next-collatz: [ dup even? [ 2 / ] [ 3 * 1 + ] branch ] ;
divrem: [ [ div ] [ % ] bi2 ] ;
gcd: [ [ dup 0 > ] [ dup bury % ] while drop ] ;
lcm: [ 2dup [ [ * abs ] dip ] dip gcd / ] ;

// calculus-ish
nd: [ dup [ over + rot bi@ - ] dip / ] ;  // forward difference approximation to the derivative