/**
 * # Core defined words
 */

// Shuffle words
slip: [ q< eval q> ] ;      // [b] A -> b A
run: [ dup slip ] ;;        // [a] -> a [a]
dip: [ swap slip ] ;;       // B [a] -> a B
sip: [ over slip ] ;;       // B [a] -> B a B    (aka keep)
over: [ dupd swap ] ;;      // B A -> B A B  (aka peek)
bi: [ sipd eval ] ;;        // C [b] [a] -> C b C a

// diped
dipd: [ q< dip q> ] ;;      // D C [b] A -> D b C A
sipd: [ q< sip q> ] ;;      // C B [a] -> C a C B
dupd: [ q< dup q> ] ;;      // B A -> B B A  (aka w)
slipd: [ q< slip q> ] ;;

do: [ dup dipd ] ;;

// alias
keep: [ over slip ] ;;      // B [a] -> B a B    (aka sip)

// math
neg: [ 0 swap - ] ;
sum: [ [ + ] reduce* ] ;

foreach: [ * eval ] ;

pop: [ 0 -1 slice ] ;
shift: [ 1 null slice ] ;

>: [ cmp 1 = ] ;
<: [ cmp -1 = ] ;
>=: [ < ~ ] ;;
<=: [ > ~ ] ;;
=<: [ > ~ ] ;;
!=: [ = ~ ] ;
get: [ q< @ dup null? swap q> swap choose ] ;
zipwith: [ zipinto in ] ;
return: [ stack send ] ;
yield: [ return suspend ] ;
delay: [ [ sleep ] >> slip eval ] ;

branch: [ choose eval ] ;
runn: [ [ -- dup -1 > ] [ [ run ] dip ] while drop ] ;

// aggregates
unit: [ [ ] >> ] ;
cons: [ >> ] ;
pair: [ unit >> ] ;
car: [ 0 @ ] ;
cdr: [ shift ] ;
first: [ 0 @ ] ;
last: [ -1 @ ] ;
rest: [ shift ] ;
head: [ 0 swap slice ] ;
tail: [ neg null slice ] ;
startswith: [ dup length [ head ] >> dip = ] ;
endswith: [ dup length [ tail ] >> dip = ] ;
contains: [ indexof 1 > ] ;
pad-left: [ over * [ swap + ] >> dip tail ] ;
lreverse: [ [ unit ] [ swap + ] map-reduce ] ;
sreverse: [ lreverse sum ] ;
reverse: [ dup string? [sreverse] [lreverse] branch ] ;;

// functional
chain: [ over nothing? ~ swap when ] ;
fmap: [ eval ] ;
reduce*: [ [ [ first ] [ rest ] bi ] dip foreach ] ;
map-reduce: [ [ map ] dip reduce* ] ;
reduce: [ [ * ] >> dip swap eval ] ;
sfilter: [ [ keepif ] >> map sum ] ;
lfilter: [ [ keepif ] >> map ] ;
filter: [ over string? [sfilter] [lfilter] branch ] ;;

// incrementors
--: [ 1 - ] ;
++: [ 1 + ] ;
pred: [ dup -- ] ;
succ: [ dup ++ ] ;

// control
times: [ runn drop ] ;
ifte: [ slipd branch ] ;
if: [ slip when ] ;
when: [ [ ] branch ] ;
guard: [ [ keep ] >> dip branch ] ;
orelse: [ [ null? ~ ] guard ] ;
keepif: [ over unit if ] ;
loop: [ [ eval ] keep 'loop' >> when ] ;
while: [ swap do + [ loop ] >> when ] ;
until: [ [ [ ~ ] + ] dip while ] ;
forever: [ [ eval ] keep forever: >> eval ] ;
either?: [ bi + ] ;

appl: [ >> in ] ;
y: [ [ dup >> ] swap + dup >> ] ;

/**
 * ## `dict`
 * returns the local dictionary
 *
 * ( -> {array} )
 */
dict: [ locals [ dup rcl ] map object ] ;
