/**
 * # Core defined words
 */

';' [ 
  [ dup defer ] swap q< eval q>  // forward definition to support recursive defintions
  bind                         // bind to scope
  def                          // define
] def

';;' [ inline def ] ;

'types.ff' require
'testing.ff' require
'shuffle.ff' require

// core shuffle words
slip: [ q< eval q> ] ;      // [b] A -> b A
run: [ dup slip ] ;;        // [a] -> a [a]
dip: [ swap slip ] ;;       // B [a] -> a B
tuck: [ swap over ] ;         // B A -> A B A

    [ [ 'b' ] 'A' slip stack [ 'b' 'A' ] assert_equal ] 'slip' test
    [ ['a'] run stack [ 'a' ['a'] ] assert_equal ] 'run' test
    [ 'B' ['a'] dip stack [ 'a' 'B' ] assert_equal ] 'dip' test

// diped
dupd: [ q< dup q> ] ;       // B A -> B B A
over: [ dupd swap ] ;      // B A -> B A B  (aka peek)
sip: [ over slip ] ;;       // B [a] -> B a B    (aka keep)
dipd: [ q< dip q> ] ;;      // D C [b] A -> D b C A
sipd: [ q< sip q> ] ;;      // C B [a] -> C a C B
slipd: [ q< slip q> ] ;;    // [c] B A -> c B A
swapd: [ q< swap q> ] ;;     // C B A -> B C A
dive: [ swap dipd ] ;;       // [c] [b] [a] -> a [c] [b]   (aka dip2)
dup2: [ over over ] ;;       // B A -> B A B A
sap: [ dip eval ] ;;    // [B] [A] -> A B

  [ [ 'b' ] [ 'a' ] sap stack [ 'a' 'b' ] assert_equal ] 'sap' test
  [ [ dup 1 - ] (5) sap stack [ 5 4 ] assert_equal ] 'sap' test
  [ +:(4, 5) sap 9 assert_equal ] 'sap' test
  [ +:(*:(5,6) sap *:(5,2) sap) sap 40 assert_equal ] 'sap' test

bi: [ sipd eval ] ;;        // C [b] [a] -> C b C a

    [ 5 [ 2 * ] [ 2 + ] bi stack [ 10 7 ] assert_equal ] 'bi' test

// swap apply `[ B ] [ A ] -> A B` (aka sap)
'|>' [ sap ] ;;

// keep/check
keep: [ sip ] ;;      // B [a] -> B a B    (aka sip)
check: [ dupd eval ] ;;     // B [a] -> B B a    (aka w)
dupn: [ [ dup ] swap times ] ;

// truthy/falsy
truthy?: [ boolean ] ;
falsy?: [ truthy? ~ ] ;;

// incrementors
--: [ 1 - ] ;
++: [ 1 + ] ;
pred: [ dup -- ] ;
succ: [ dup ++ ] ;

// Comparisons
>: [ <=> 1 = ] ;
<: [ <=> -1 = ] ;
>=: [ < ~ ] ;;
<=: [ > ~ ] ;;
!=: [ = ~ ] ;

// 
in: [ ( swap eval ) ] ;
get: [ q< @ dup null? swap q> swap choose ] ;
zipwith: [ zipinto in ] ;
return: [ stack send ] ;
yield: [ return suspend ] ;
delay: [ [ sleep ] >> slip eval ] ;

// control
_do: [ dup dipd ] ;;
_check: [ q< q< boolean q> q> ] ;
branch: [ _check choose eval ] ;;
when: [ [ ] branch ] ;
unless: [ [ ] swap branch ] ;
ifte: [ slipd branch ] ;;
if: [ slip when ] ;
loop: [ [ eval ] keep [ loop ] >> when ] ;
while: [ swap _do + [ loop ] >> when ] ;

// aggregates
slice: [ [ % ] dip \ ] ;
pop: [ -1 \ ] ;
shift: [ 1 % ] ;
car: [ 0 @ ] ;
cdr: [ 1 % ] ;
first: [ 0 @ ] ;
last: [ -1 @ ] ;
rest: [ 1 % ] ;
head: [ \ ] ;
tail: [ % ] ;
startswith: [ dup ln [ head ] >> dip = ] ;;
endswith: [ dup ln [ tail ] >> dip = ] ;;
contains: [ indexof 1 > ] ;

// lists
empty?: [ ln 0 = ] ;
unit: [ [ ] >> ] ;
cons: [ >> ] ;
pair: [ unit >> ] ;
uncons: [ [ first ] [ rest ] bi ] ;;

// folds
each: [ * eval ] ;
reverse-each: [ / eval ] ;
foldl: [ swapd each ] ;;
foldr: [ [ swap ] swap + swapd reverse-each ] ;;
foldl1: [ [ uncons ] dip each ] ;;
foldr1: [ [ uncons ] dip reverse-each ] ;;
fold: [ foldl1 ] ;;
runn: [ [ -- dup -1 > ] [ [ run ] dip ] while drop ] ;
times: [ runn drop ] ;
guard: [ [ keep ] >> dip branch ] ;
orelse: [ [ null? ~ ] guard ] ;
keepif: [ over unit if ] ;
until: [ [ [ ~ ] + ] dip while ] ;
forever: [ [ eval ] keep [ forever ] >> eval ] ;
either?: [ bi + ] ;

appl: [ >> in ] ;
y: [ [ dup >> ] swap + dup >> ] ;

// functional
map: [ * in ] ;;

    [ [ 1 2 3 ] [ 2 * ] map [ 2 4 6 ] assert_equal ] 'map' test
    [ [ 1 2 3 4 ] [ 2 % 0 = ] map [ false true false true ] assert_equal ] 'map' test

chain: [ over nothing? ~ swap when ] ;
fmap: [ eval ] ;
map-reduce: [ [ map ] dip fold ] ;
reduce: [ foldl ] ;;
filter: [ [ dup empty swap ] dip [ keepif ] >> map swap * ] ;

    [ [ 1 2 3 4 ] [ 2 % 0 = ] filter [ 2 4 ] assert_equal ] 'filter' test
    [ [ 1 2 3 4 ] [ 2 > ] filter [ 3 4 ] assert_equal ] 'filter' test

// aggregate reduction
reverse: [ dup ln 1 > [ uncons [ reverse ] eval swap + ] when ] ;

    [ 'abcd' reverse 'dcba' assert_equal ] 'reverse' test

/**
  * ## `nop`
  * no op
  *
  * ( -> )
  */
nop: [] ;

/**
 * Calls the second quotation in the first pair whose first quotation yields a truthy value.
 */
cond: [
  dup empty?
  [
    uncons slip slipd
    [ cond ] >>
    branch
  ] unless
] ;

/**
 * Calls the second quotation in the first pair whose first quotation matches the last item on the stack
 */
p-cond: [
  dup empty?
  [
    uncons [ eval [ dupd =~ ] dip ] dip
    [ p-cond ] >>
    branch
  ] unless
] ;

/**
 * Returns the second item in the first pair whose first quotation matches the last item on the stack
 */
p-choose: [
  dup empty?
  [
    uncons [ eval [ dupd =~ ] dip [ drop ] swap << ] dip
    [ p-choose ] >>
    branch
  ] unless
] ;

/**
 * quicksort
*/
qsort: [
  dup ln 1 >             // when length > 1
  [
    uncons                      // split into first [ ...rest ]
    over dup                    // shuffle
    [ [ <= ] >> filter ] >>     // filter values less than or equal to pivot
    swap [ [ > ] >> filter ] >> // filter values greater than the pivot
    bi
    [ qsort ] bi@           // quicksort each sublist
    [ swap + ] dip +            // merge results 
  ] when
] ;

    [
      [ 3 2 1 ] qsort [ 1 2 3 ] assert_equal
      [ -3 2 1 ] qsort [ -3 1 2 ] assert_equal
      [ -3 2 -1 ] qsort [ -3 -1 2 ] assert_equal
      [ 10 2 5 3 1 6 7 4 2 3 4 8 9 ] qsort [ 1 2 2 3 3 4 4 5 6 7 8 9 10 ] assert_equal
      "the quick brown fox jumps over the lazy dog" qsort '        abcdeeefghhijklmnoooopqrrsttuuvwxyz' assert_equal
    ] 'qsort' test
