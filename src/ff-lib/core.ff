/**
 * # Core defined words
 */
'types.ff' import use

// Shuffle words
slip: [ q< eval q> ] ;      // [b] A -> b A
run: [ dup slip ] ;;        // [a] -> a [a]
dip: [ swap slip ] ;;       // B [a] -> a B
sip: [ over slip ] ;;       // B [a] -> B a B    (aka keep)

// diped
dipd: [ q< dip q> ] ;;      // D C [b] A -> D b C A
sipd: [ q< sip q> ] ;;      // C B [a] -> C a C B
dupd: [ q< dup q> ] ;       // B A -> B B A
slipd: [ q< slip q> ] ;;    // [c] B A -> c B A
over: [ dupd swap ] ;;      // B A -> B A B  (aka peek)
swapd: [ q< swap q> ] ;     // C B A -> B C A

bi: [ sipd eval ] ;;        // C [b] [a] -> C b C a
do: [ dup dipd ] ;;

// keep/check
keep: [ over slip ] ;;      // B [a] -> B a B    (aka sip)
check: [ dupd eval ] ;;     // B [a] -> B B a    (aka w)

// Comparisons
>: [ <=> 1 = ] ;
<: [ <=> -1 = ] ;
>=: [ < ~ ] ;;
<=: [ > ~ ] ;;
=<: [ > ~ ] ;;
!=: [ = ~ ] ;

max: [ dup2 q< q< > q> q> choose ] ;;
min: [ dup2 q< q< < q> q> choose ] ;;

// 
get: [ q< @ dup null? swap q> swap choose ] ;
zipwith: [ zipinto in ] ;
return: [ stack send ] ;
yield: [ return suspend ] ;
delay: [ [ sleep ] >> slip eval ] ;

// control
branch: [ choose eval ] ;
when: [ [ ] branch ] ;
unless: [ [ ] swap branch ] ;
ifte: [ slipd branch ] ;;
if: [ slip when ] ;
while: [ swap do + [ loop ] >> when ] ;

each: [ * eval ] ;
reverse-each: [ / eval ] ;
foldl: [ swapd each ] ;;
foldr: [ [ swap ] swap + swapd reverse-each ] ;;
foldl1: [ [ xxs ] dip each ] ;;
foldr1: [ [ xxs ] dip reverse-each ] ;;
fold: [ foldl1 ] ;;
runn: [ [ -- dup -1 > ] [ [ run ] dip ] while drop ] ;
times: [ runn drop ] ;
guard: [ [ keep ] >> dip branch ] ;
orelse: [ [ null? ~ ] guard ] ;
keepif: [ over unit if ] ;
loop: [ [ eval ] keep [ loop ] >> when ] ;
until: [ [ [ ~ ] + ] dip while ] ;
forever: [ [ eval ] keep forever: >> eval ] ;
either?: [ bi + ] ;

// pattern matching
pattern-branch: [ pattern-choose eval ] ;

appl: [ >> in ] ;
y: [ [ dup >> ] swap + dup >> ] ;

// Lists
unit: [ [ ] >> ] ;
cons: [ >> ] ;
pair: [ unit >> ] ;

// aggregates
slice: [ [ % ] dip \ ] ;
pop: [ -1 \ ] ;
shift: [ 1 % ] ;
car: [ 0 @ ] ;
cdr: [ 1 % ] ;
first: [ 0 @ ] ;
last: [ -1 @ ] ;
rest: [ 1 % ] ;
head: [ \ ] ;
tail: [ % ] ;
xxs: [ [ first ] [ rest ] bi ] ;;
startswith: [ dup ln [ head ] >> dip = ] ;;
endswith: [ dup ln [ tail ] >> dip = ] ;;
contains: [ indexof 1 > ] ;

// functional
chain: [ over nothing? ~ swap when ] ;
fmap: [ eval ] ;
map-reduce: [ [ map ] dip fold ] ;
reduce: [ foldl ] ;;
filter: [ [ dup empty swap ] dip [ keepif ] >> map swap * ] ;

// aggregate reduction
maximum: [ [ max ] fold ] ;;
minimum: [ [ min ] fold ] ;;
reverse: [ dup ln 1 <= [ ] [ xxs reverse swap + ] branch ] ;

flatten*: [
  dup array?
  [ [ flatten* ] foreach ]
  when
] ;
flatten: [ [ flatten* ] appl ] ;



// math
neg: [ 0 swap - ] ;
sum: [ [ + ] fold ] ;

// incrementors
--: [ 1 - ] ;
++: [ 1 + ] ;
pred: [ dup -- ] ;
succ: [ dup ++ ] ;

// control

/**
 * ## `dict`
 * returns the local dictionary
 *
 * ( -> {array} )
 */
dict: [ locals [ dup rcl ] map object ] ;

/**
  * ## `nop`
  * no op
  *
  * ( -> )
  */
nop: [] ;
