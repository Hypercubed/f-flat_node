import { signature, Any } from '@hypercubed/dynamo';

import { ffPrettyPrint, FFlatError, rewrite } from '../utils';
import { dynamo, Sentence, Key, StackValue, ScopeModule } from '../types';
import { StackEnv } from '../engine/env';

/**
 * Converts a stack item to a "function" definition
 */
class CreateAction {
  // arrays are converted to sentences
  @signature()
  array(x: any[]): Sentence {
    return new Sentence(x);
  }

  // objects are converted to and object of actions
  @signature()
  plainObject(obj: Object) {
    return Object.keys(obj).reduce((p, key) => {
      p[key] = createAction(obj[key]);
      return p;
    }, {});
  }

  // symbols are symbols
  @signature(Symbol)
  symbol(x: any): any {
    return x;
  }

  // everything else is converetd to a sentence containing the single item
  @signature(Any)
  any(x: any): any {
    return new Sentence([x]);
  }
}

const createAction = dynamo.function(CreateAction);

// For all dictionary actions, note:
// * The dictionary is mutable
// * Stack items are immutable

/**
 * # Internal Vocabulary Words
 */
export const dict = {
  /**
   * ## `defer`
   *
   * Stores a value in the dictionary that raises an error when executed.
   * Used to allocate a word before it is used, for example in mutually-recursive
   *
   * ( a: -> )
   *
   * ```
   * f♭> a: defer
   * [ ]
   * ```
   */
  defer(this: StackEnv, lhs: string | Key) {
    try {
      this.dict.set(String(lhs), undefined);
    } catch (e) {
      throw new FFlatError(e.message, this);
    }
  },

  /**
   * ## `def`
   *
   * stores a definition in the current dictionary
   *
   * ( {string|atom} [A] -> )
   *
   * ```
   * f♭> [ dup * ] "sqr" sto
   * [ ]
   * ```
   */
  def(this: StackEnv, lhs: string | Key, rhs: StackValue[] | ScopeModule) {
    try {
      this.dict.set(String(lhs), createAction(rhs));
    } catch (e) {
      throw new FFlatError(e.message, this);
    }
  },

  /**
   * ## `use`
   *
   * Move the contents of a map into scope
   * - The map must be a map of keys to global symbols generated by `vocab`
   *
   * ( { ... } -> )
   *
   * ```
   * f♭> { ... } use
   * [ ]
   * ```
   */
  use(this: StackEnv, dict: ScopeModule) {
    try {
      this.dict.useVocab(createAction(dict)); // TODO: only allow namespaces
    } catch (e) {
      throw new FFlatError(e.message, this);
    }
  },

  /**
   * ## `vocab`
   *
   * Write the current local vocabulary to the stack
   * - The mreturned value is a map of strings to global symbols generated
   *
   * ( -> { ... })
   *
   * ```
   * f♭> vocab
   * [ { ... } ]
   * ```
   */
  vocab(this: StackEnv) {
    return this.dict.getVocab();
  },

  /**
   * ## `inline`
   *
   * inline a quote, recursively expands defined words to global symbols
   *
   * ( [A B C] -> [a b c])
   *
   * ```
   * f♭> [ 2 sqr ] inline
   * [ [ 2 dup * ] ]
   * ```
   */
  inline(this: StackEnv, x: Array<StackValue>) {
    return this.dict.inline(x);
  },

  /**
   * ## `defined?`
   * returns true if the word is defined in the current vocabulary
   *
   * ( 'a' -> bool )
   *
   * ```
   * f♭> 'sqr' defined?
   * [ true ]
   * ```
   */
  'defined?'(this: StackEnv, a: string) {
    try {
      const r = this.dict.get(a);
      return typeof r !== 'undefined';
    } catch (e) {
      throw new FFlatError(e.message, this);
    }
  },

  /**
   * ## `see`
   *
   * recalls the definition of a word as a string
   *
   * ( {string|atom} -> {string} )
   *
   * ```
   * f♭> 'sqr' see
   * [ '[ dup * ]' ]
   * ```
   */
  see(this: StackEnv, a: string | Key) {
    try {  // may error on bad key
      const r = this.dict.get(String(a));
      if (typeof r === 'undefined') {
        return null;
      }
      return ffPrettyPrint.stringify(r);
    } catch (e) {
      throw new FFlatError(e.message, this);
    }
  },

  /**
   * ## `show`
   *
   * prints the definition of a word as a formatted string
   *
   * ( {string|atom} -> {string} )
   *
   * ```
   * f♭> "sqr" show
   * [ '[ dup * ]' ]
   * ```
   */
  show(this: StackEnv, a: string) {
    try {
      const r = this.dict.get(String(a));
      return console.log(ffPrettyPrint.color(r));
    } catch (e) {
      throw new FFlatError(e.message, this);
    }
  },

  /**
   * ## `words`
   *
   * returns a list of defined words
   *
   * ( -> {array} )
   */
  words(this: StackEnv): string[] {
    return this.dict.words();
  },

  /**
   * ## `locals`
   *
   * returns a list of locals words
   *
   * ( -> {array} )
   */
  locals(this: StackEnv): string[] {
    return this.dict.localWords();
  },

  /**
   * ## `scoped`
   *
   * returns a list of local scoped words
   *
   * ( -> {array} )
   */
  scoped(this: StackEnv): string[] {
    return this.dict.scopedWords();
  },

  /**
   * ## `rewrite`
   *
   * rewrites an expression using a set of rewrite rules
   *
   * ( {expression} {object} -> {expression} )
   *
   */
  rewrite(this: StackEnv, rules: Object, a: string) {
    return rewrite(a, rules);
  },

  'show-globals'(this: StackEnv) {
    const obj = (this.dict as any).global;
    const keys = Object.getOwnPropertySymbols(obj);
    keys.forEach((key) => {
      const body = obj[key];
      console.log(ffPrettyPrint.trace(key), typeof body === 'function' ? '[internal]' : ffPrettyPrint.trace(obj[key]));
    });

    console.log(` - ${keys.length} global symbols - `);
  },

  // 'global-sif'(this: StackEnv) {
  //   const obj = (this.dict as any).global;
  //   const keys = Object.getOwnPropertySymbols(obj);
  //   keys.forEach((key) => {
  //     const body = obj[key];
  //     if (body instanceof Sentence) {
  //       body.value.flat(Infinity).forEach((v: any) => {
  //         if (v instanceof Alias) {
  //           console.log(key.description, '(calls)' , v.toString());
  //         }
  //       });
  //     }
  //   });
  // },

  // 'global-adj-sif'(this: StackEnv) {
  //   const obj = (this.dict as any).global;
  //   const keys = Object.getOwnPropertySymbols(obj);
  //   keys.forEach((key) => {
  //     const body = obj[key];
  //     if (body instanceof Sentence) {
  //       let last: any = null;
  //       body.value.flat(Infinity).forEach((v: any) => {
  //         if (v instanceof Alias) {
  //           if (last) {
  //             console.log(last.toString(), '->' , v.toString());
  //           }
  //           last = v;
  //         }
  //       });
  //     }
  //   });
  // },

  // 'global-nnf'(this: StackEnv) {
  //   const obj = (this.dict as any).global;
  //   const keys = Object.getOwnPropertySymbols(obj);
  //   console.log(['caller', 'first', 'second'].join(','));
  //   keys.forEach((key) => {
  //     const body = obj[key];
  //     if (body instanceof Sentence) {
  //       let last: any = null;
  //       body.value.flat(Infinity).forEach((v: any) => {
  //         if (v instanceof Alias) {
  //           if (last) {
  //             console.log([key.description, last.toString(), v.toString()].join(','));
  //           }
  //           last = v;
  //         }
  //       });
  //     }
  //   });
  // }
};
