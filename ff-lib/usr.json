{
  "!=": "= not",
  "unit": "() >>",
  "cons": ">>",
  "pair": "unit >>",
  "car": "0 @",
  "cdr": "shift",
  "first": "0 @",
  "last": "-1 @",
  "rest": "shift",
  "head": "0 swap slice",
  "tail": "neg null slice",
  "compose": "+",
  "prepose": "swap +",
  "appl": ">> in",
  "with": "[ swap [ swap ] ] dip + >>",
  "spawn2": "[ spawn ] dip spawn",
  "eval2": "[ eval ] dip eval",
  "spawnsplit": "spawn2 eval2",
  "runn": "[ -- dup -1 > ] [ [ run ] dip ] while drop",
  "times": "runn drop",
  "replicate": "[ unit ] dip *",
  "countup": "over - [ succ ] swap",
  "countdown": "dupd - [ pred ] swap",
  "range*": "dup2 < [ countup ] [ countdown ] branch repn",
  "range": "[ range* ] >> appl",
  "count": "1 swap range*",
  "integers": "[ count ] appl",
  "branch": "choose eval",
  "ifte": "[ slip ] dip branch",
  "if": "slip when",
  "when": "() branch",
  "guard": "[ keep ] >> dip branch",
  "orelse": "[ null? not ] guard",
  "either?": "bi@ +",
  "keepif": "over unit if",
  "filter": "[ keepif ] >> map",
  "time": "clock swap 100 repn clock swap - 100 /",
  "reduce": "[ * ] >> dip swap eval",
  "reduce*": "[ [ first ] [ rest ] bi ] dip step",
  "map-reduce": "[ map ] dip reduce*",
  "sum": "[ + ] reduce*",
  "product": "[ * ] reduce*",
  "lreverse": "[ unit ] [ swap + ] map-reduce",
  "sreverse": "lreverse sum",
  "reverse": "dup string? [ sreverse ] [ lreverse ] branch",
  "_timefn": "clock swap [ dup in drop ] 1000 repn drop clock -",
  "timefn": "_timefn () _timefn - -1000 / inv ' ops/sec' + ",
  "startswith": "dup length [ head ] >> dip =",
  "endswith": "dup length [ tail ] >> dip =",
  "contains": "indexof 1 >",
  "loop": "[ eval ] keep 'loop' >> when",
  "not": "false =",
  "find-next": "[ ++ dup ] swap + [ not ] + loop",
  "next-odd": "[ odd? ] find-next",
  "next-even": "[ even? ] find-next",
  "while": "swap do + [ loop ] >> when",
  "until": "[ [ not ] + ] dip while",
  "forever": "[ eval ] keep 'forever' >> eval",
  "prime?": "dup 7 < [ [ 2 = ] [ 3 = ] [ 5 = ] tri + + ] [ dup simple? [ drop false ] [ prime?* ] branch ] branch",
  "prime?*": "2 [ dup2 2 ^ > [ dup2 % 0 > ] dip swap * ] [ ++ ] while 2 ^ <",
  "next-prime": "dup 2 < [ drop 2 ] [ next-odd [ dup prime? ] [ 2 + ] until ] branch",
  "nth-prime": "[ 0 [ next-prime ] ] dip times",
  "divisors": "[ 2 [ dup2 2 ^ > ] [ dup2 divisor? [ tuck / over ] [ next-odd ] branch ] while drop ] appl",
  "next-fib": "dup2 +",
  "fib": "( 0 1 [ next-fib ] ) dip -- repn drop",
  "next-fib*": "tuck +",
  "fib*": "( 0 1 ) dip [ 0 1 [ tuck + ] yield ] [ in ] rolldown 2 - repn drop",
  "count*": "[ 0 [ ++ dup yield: dip ] forever ]",
  "cycle*": "[ [ 1 splitat swap [ + ] keep eval send suspend ] forever ] >>",
  "fetch-json": "fetch parse-json",
  "site-size": "fetch length",
  "site-war": "dup [ [ site-size ] >> ] map all zip object",
  "rand-integer": "rand-u32",
  "rand-char": "rand-integer 128 % itoa",
  "rand-seq": "rand-integer 16 % ++ [ times ] >> >> in",
  "rand-string": "[ rand-char ] rand-seq sum",
  "rand-bool": "rand-u32 even?",
  "empty?": "length zero?",
  "for-all": "[ [ 100 times ] >> in ] dip [ not ] + filter",
  "check-for-all": "for-all dup empty? [ '+++ OK, passed 100 tests.' println drop ] [ [ ' Failed!' + println ] map ] branch",
  "inline": "dup rcl expand swap def",
  "inline-dict": "words [ inline ] step",
  "between?": "swap dupd < bury < *",
  "lcase-char?": "atoi [ 96 123 ] dip between?",
  "ucase-char?": "atoi [ 64 91 ] dip between?",
  "lcase-char": "dup ucase-char? [ atoi 32 + itoa ] when",
  "ucase-char": "dup lcase-char? [ atoi 32 - itoa ] when",
  "char?": "[ lcase-char? ] [ ucase-char? ] bi or",
  "rot13-char*": "[ atoi ] dip [ - 13 + 26 % ] [ + ] bi itoa",
  "rot13-char": "dup ucase-char? [ 65 ] [ 97 ] branch rot13-char*",
  "char-map": "map sum",
  "rot13": "[ rot13-char ] char-map",
  "ucase": "[ ucase-char ] char-map",
  "lcase": "[ lcase-char ] char-map",
  "trace": "trace: set-log-level",
  "divrem": "[ div ] [ rem ] bi2",
  "gcd": "[ dup 0 > ] [ dup bury rem ] while drop",
  "lcm": "dup2 [ [ * abs ] dip ] dip gcd /",
  "next-collatz": "dup even? [ 2 / ] [ 3 * 1 + ] branch",
  "collatz": "[ [ dup, 1, > ], [ dup, next-collatz ], while ] >> in",
  "timing": "timing: set-log-level",
  "pad-left": "over * [ swap + ] >> dip tail"
}
