{
  "unit": "[] >>",
  "cons": "unit >>",
  "car": "0 @",
  "cdr": "shift",
  "first": "0 @",
  "last": "-1 @",
  "rest": "shift",
  "head": "0 swap slice",
  "tail": "neg null slice",
  "cleave": "[ keep ] dip eval",
  "keep": "over slip",
  "dupd": "[ dup ] dip",
  "dropd": "[ drop ] dip",
  "over": "dupd swap",
  "roll": "swap [ swap ] dip",
  "rolld": "[ swap ] dip swap",
  "rot": "roll swap",
  "nip": "swap drop",
  "tuck": "swap over",
  "dup2": "over over",
  "dipd": "[ dip ] dip",
  "times": "* eval",
  "upto": "over - [ succ ] swap times",
  "count": "1 swap upto",
  "branch": "choose eval",
  "ifte": "[ eval ] dipd branch",
  "if": "[ ] ifte",
  "time": "clock swap 100 times clock swap - 100 /",
  "reduce": "[ * ] >> dip swap eval",
  "sum": "0 [ + ] reduce",
  "product": "1 [ * ] reduce",
  "inv": "1 swap /",
  "_timefn": "clock swap [ dup in drop ] 1000 times drop clock -",
  "timefn": "_timefn [ ] _timefn - -1000 / inv \" ops/sec\" + ",
  "startswith": "dup length [ head ] >> dip =",
  "endswith": "dup length [ tail ] >> dip =",
  "contains": "indexof 1 >",
  "run": "dup dip",
  "appl": ">> in",
  "integers": "[ count ] appl",
  "loop": "[ eval ] keep [ loop ] >> when",
  "when": "[] branch",
  "find-next": "[ ++ dup ] swap + [ not ] + loop",
  "next-odd": "[ odd? ] find-next",
  "next-even": "[ even? ] find-next",
  "zero?": "0 =",
  "odd?": "2 % zero? not",
  "even?": "2 % zero?",
  "not": "false =",
  "do": "dup [ dip ] dip",
  "while": "swap do + [ loop ] >> when",
  "prime?": "2 [ dup2 2 ^ > [ dup2 % 0 > ] dip swap * ] [ ++ ] while 2 ^ <",
  "next-fib": "over over +",
  "fib": "[ 0 1 [ next-fib ] ] dip -- times drop",
  "next-fib*": "swap over +",
  "fib*": "[ 0 1 ] dip [ 0 1 [ swap over + ] yield ] [ in ] rolld 2 - times drop",
  "succ*": "[ 0 [ ++ dup yield: dip true ] loop ]"
}
