{
  "slip": ">r eval <r",
  "dip": "swap slip",
  "cleave": "[ keep ] dip eval",
  "keep": "over slip",
  "dupd": "[ dup ] dip",
  "dropd": "[ drop ] dip",
  "over": "dupd swap",
  "--": "1 -",
  "++": "1 +",
  "neg": "0 swap -",
  "pred": "dup --",
  "succ": "dup ++",
  "times": "* eval",
  "upto": "over - [ succ ] swap times",
  "count": "1 swap upto",
  "~!": "++ gamma",
  "c!": "pred [ count ] dip [ * ] swap times",
  "r!": "dup 0 = [ drop 1 ] [ pred r! * ] branch",
  "!": "dup 25 < [ pred [ count ] dip [ * ] swap times ] [ ++ gamma ] branch",
  "npr": "[ [ ! ] keep ] dip - ! /",
  "ncr": "[ npr ] keep ! / round",
  "branch": "choose eval",
  "dipd": "[ dip ] dip",
  "ifte": "[ eval ] dipd branch",
  "if": "[ ] ifte",
  "^^^": "[ dup [ swap ^^ ] >> ] dip -- times",
  "^^": "[ dup [ swap ^ ] >> ] dip -- times",
  "time": "clock swap 100 times clock swap - 100 /",
  "reduce": "[ * ] >> dip swap eval",
  "sum": "0 [ + ] reduce",
  "map": "* in",
  "product": "1 [ * ] reduce",
  "first": "0 at",
  "last": "-1 at",
  "inv": "1 swap /",
  "_timefn": "clock swap [ dup in drop ] 1000 times drop clock -",
  "timefn": "_timefn [ ] _timefn - -1000 / inv \" ops/sec\" + ",
  "head": "0 swap slice",
  "tail": "neg null slice",
  "startswith": "dup length [ head ] >> dip =",
  "endswith": "dup length [ tail ] >> dip =",
  "contains": "indexof 1 >"
}
