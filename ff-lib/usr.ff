// functional
chain: [ over nothing? not swap when ] ;
fmap: [ eval ] ;
map-reduce: [ [ map ] dip reduce* ] ;
reduce: [ [ * ] >> dip swap eval ] ;
reduce*: [ [ [ first ] [ rest ] bi ] dip foreach ] ;
filter: [ [ keepif ] >> map ] ;

// Misc
compose: [ + ] ;
prepose: [ swap + ] ;
appl: [ >> in ] ;
with: [ [ swap [ swap ] ] dip + >> ] ;
eval2: [ slip eval ] ;
replicate: [ [ unit ] dip * ] ;
y: [ [ dup >> ] swap + dup >> ] ;
nth: [ -- @ ] ;

// timing
time: [ clock swap 100 repn clock swap - 100 / ] ;
_timefn: [ clock swap [ dup in drop ] 1000 repn drop clock - ] ;
timefn: [ _timefn () _timefn - -1000 / inv ' ops/sec' +  ] ;

// side effects
trace: [ trace: set-log-level ] ;
timing: [ timing: set-log-level ] ;

// dictionary
inline: [ dup rcl expand swap def ] ;

// control
runn: [ [ -- dup -1 > ] [ [ run ] dip ] while drop ] ;
times: [ runn drop ] ;
branch: [ choose eval ] ;
ifte: [ slipd branch ] ;
if: [ slip when ] ;
when: [ () branch ] ;
guard: [ [ keep ] >> dip branch ] ;
orelse: [ [ null? not ] guard ] ;
keepif: [ over unit if ] ;
loop: [ [ eval ] keep 'loop' >> when ] ;
while: [ swap do + [ loop ] >> when ] ;
until: [ [ [ not ] + ] dip while ] ;
forever: [ [ eval ] keep 'forever' >> eval ] ;

// aggregates
unit: [ () >> ] ;
cons: [ >> ] ;
pair: [ unit >> ] ;
car: [ 0 @ ] ;
cdr: [ shift ] ;
first: [ 0 @ ] ;
last: [ -1 @ ] ;
rest: [ shift ] ;
head: [ 0 swap slice ] ;
tail: [ neg null slice ] ;
startswith: [ dup length [ head ] >> dip = ] ;
endswith: [ dup length [ tail ] >> dip = ] ;
contains: [ indexof 1 > ] ;
pad-left: [ over * [ swap + ] >> dip tail ] ;
lreverse: [ [ unit ] [ swap + ] map-reduce ] ;
sreverse: [ lreverse sum ] ;
reverse: [ dup string? [ sreverse ] [ lreverse ] branch ] ;

// quick check
for-all: [ [ [ 100 times ] >> in ] dip [ not ] + filter ] ;
check-for-all: [ for-all dup empty? [ '+++ OK, passed 100 tests.' println drop ] [ [ ' Failed!' + println ] map ] branch ] ;

// strings
lcase-char: [ dup ucase-char? [ atoi 32 + itoa ] when ] ;
ucase-char: [ dup lcase-char? [ atoi 32 - itoa ] when ] ;
rot13-char*: [ [ atoi ] dip [ - 13 + 26 % ] [ + ] bi itoa ] ;
rot13-char: [ dup ucase-char? [ 65 ] [ 97 ] branch rot13-char* ] ;
char-map: [ map sum ] ;
rot13: [ [ rot13-char ] char-map ] ;
ucase: [ [ ucase-char ] char-map ] ;
lcase: [ [ lcase-char ] char-map ] ;

// generators
next-fib*: [ tuck + ] ;
fib*: [ ( 0 1 ) dip [ 0 1 [ tuck + ] yield ] [ in ] rolldown 2 - repn drop ] ;
count*: [ [ 0 [ ++ dup yield: dip ] forever ] ] ;
cycle*: [ [ [ 1 splitat swap [ + ] keep eval send suspend ] forever ] >> ] ;

// async
spawnsplit: [ spawn2 eval2 ] ;
spawn2: [ [ spawn ] dip spawn ] ;

// fetch
fetch-json: [ fetch parse-json ] ;
site-size: [ fetch length ] ;
site-war: [ dup [ [ site-size ] >> ] map all zip object ] ;

// random
rand-integer: [ rand-u32 ] ;
rand-char: [ rand-integer 128 % itoa ] ;
rand-seq: [ rand-integer 16 % ++ [ times ] >> >> in ] ;
rand-string: [ [ rand-char ] rand-seq sum ] ;
rand-bool: [ rand-u32 even? ] ;

// math-ish
sum: [ [ + ] reduce* ] ;
product: [ [ * ] reduce* ] ;
countup: [ over - [ succ ] swap ] ;
countdown: [ dupd - [ pred ] swap ] ;
range*: [ 2dup < [ countup ] [ countdown ] branch repn ] ;
range: [ [ range* ] >> appl ] ;
count: [ 1 swap range* ] ;
integers: [ [ count ] appl ] ;
find-next: [ [ ++ dup ] swap + [ not ] + loop ] ;
next-odd: [ [ odd? ] find-next ] ;
next-even: [ [ even? ] find-next ] ;
divisors: [ [ 2 [ 2dup 2 ^ > ] [ 2dup divisor? [ tuck / over ] [ next-odd ] branch ] while drop ] appl ] ;
next-fib: [ 2dup + ] ;
fib: [ ( 0 1 [ next-fib ] ) dip -- repn drop ] ;
collatz: [ [ [ dup 1 > ] [ dup next-collatz ] while ] >> in ] ;
next-collatz: [ dup even? [ 2 / ] [ 3 * 1 + ] branch ] ;
divrem: [ [ div ] [ rem ] bi2 ] ;
gcd: [ [ dup 0 > ] [ dup bury rem ] while drop ] ;
lcm: [ 2dup [ [ * abs ] dip ] dip gcd / ] ;

// primes
prime?: [ dup 7 < [ [ 2 = ] [ 3 = ] [ 5 = ] tri + + ] [ dup simple? [ drop false ] [ prime?* ] branch ] branch ] ;
prime?*: [ 2 [ 2dup 2 ^ > [ 2dup % 0 > ] dip swap * ] [ ++ ] while 2 ^ < ] ;
next-prime: [ dup 2 < [ drop 2 ] [ next-odd [ dup prime? ] [ 2 + ] until ] branch ] ;
nth-prime: [ [ 0 [ next-prime ] ] dip times ] ;

// inquisitive
either?: [ bi@ + ] ;
lcase-char?: [ atoi [ 96 123 ] dip between? ] ;
ucase-char?: [ atoi [ 64 91 ] dip between? ] ;
empty?: [ length zero? ] ;
between?: [ swap dupd < bury < * ] ;
char?: [ [ lcase-char? ] [ ucase-char? ] bi or ] ;
